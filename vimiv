#!/usr/bin/python3
# encoding: utf-8

try:
    import sys
    import os
    import signal
    import shutil
    import argparse
    from random import shuffle
    import mimetypes
    from gi import require_version
    require_version('Gtk', '3.0')
    from gi.repository import GLib, Gtk, Gdk, GdkPixbuf
    from PIL import Image, ImageEnhance
    from subprocess import call, Popen, PIPE
    # Settings
    sys.path.append(os.path.join(os.path.expanduser("~"), ".vimiv"))
    sys.path.append("/etc/vimiv")
    import vimivrc as settings

except ImportError as e:
    print(e)
    print("Are all dependencies installed "
          "and is the configfile in the correct directory?")
    sys.exit(1)

except NameError as e:
    print(e)
    print("Did you quote all strings in your config?")
    sys.exit(1)


class Vimiv(Gtk.Window):

    def __init__(self):
        try:
            # The configruations from vimivrc
            self.fullscreen = bool(settings.start_fullscreen)
            self.slideshow = bool(settings.start_slideshow)
            self.slideshow_delay = float(settings.slideshow_delay)
            self.shuffle = bool(settings.shuffle)
            self.sbar = bool(settings.display_bar)
            self.thumbnail_toggled = False
            self.library_toggled = bool(settings.show_library)
            self.library_focused = False
            self.library_width = int(settings.library_width)
            self.geometry = str(settings.geometry)
            self.recursive = bool(settings.recursive)
            self.rescale_svg = bool(settings.rescale_svg)
            self.animation_toggled = False
            self.winsize = (100, 100)  # necessary for checks
            self.cmd_history = [""]  # Remember cmd history
            self.cmd_pos = 0

            self.paths = []
            # Get supported mimetypes
            self.types = []
            for pixbuf_format in GdkPixbuf.Pixbuf.get_formats():
                self.types.extend(pixbuf_format.get_mime_types())
            self.marked = []
            self.marked_bak = []  # saves marked images after marked toggle
            self.manipulate_toggled = False
            self.user_zoomed = False  # checks if the user manually zoomed the
            #                      image, necessary for the auto_resize function
            self.num_str = ""  # used to prepend actions with numbers
            self.dir_pos = {}  # Remembers positions in the library browser
            self.error = []

            self.thumbsize = tuple(settings.thumbsize)
            try:
                int(self.thumbsize[0])
                int(self.thumbsize[1])
                if len(self.thumbsize) != 2:
                    raise ValueError
            except ValueError as e:
                print("The Type of your thumbsize tuple is wrong. It should be "
                      "of the form (Int, Int).")
                sys.exit(1)

            self.border_width = int(settings.border_width)
            border_color = str(settings.border_color)
            try:
                if len(border_color) != 7 or border_color[0] != "#":
                    raise ValueError
                self.border_color = Gdk.color_parse(border_color)
            except:
                print("Border color in config not given in the correct form,",
                      "falling back to default.")
                self.border_color = Gdk.color_parse("#000000")
            self.expand_lib = settings.expand_lib
            self.show_hidden = bool(settings.show_hidden)

            self.mainbinds = (
                (settings.key_quit, self.quit),
                ("^q", self.quit),
                (settings.key_animation_toggle, self.animation_toggle),

                (settings.key_fullscreen_toggle, self.toggle_fullscreen),
                (settings.key_statusbar_toggle, self.toggle_statusbar),
                (settings.key_slideshow_toggle, self.toggle_slideshow),
                (settings.key_thumbnail_toggle, self.thumbnail_toggle),
                (settings.key_library_toggle, self.library_toggle),
                (settings.key_library_toggle_focus, self.library_focus, True),
                (settings.key_rescale_toggle, self.toggle_rescale_svg),
                (settings.key_move_up, self.move_up),

                # if True, scroll in the horizontal direction.
                (settings.key_scroll_left, self.scroll,
                 Gtk.ScrollType.STEP_BACKWARD, True, False),
                (settings.key_scroll_down, self.scroll,
                 Gtk.ScrollType.STEP_FORWARD, False, False),
                (settings.key_scroll_up, self.scroll,
                 Gtk.ScrollType.STEP_BACKWARD, False, False),
                (settings.key_scroll_right, self.scroll,
                 Gtk.ScrollType.STEP_FORWARD, True, False),
                # Also with the arrow keys
                ("Left", self.scroll,
                 Gtk.ScrollType.STEP_BACKWARD, True, True),
                ("Down", self.scroll,
                 Gtk.ScrollType.STEP_FORWARD, False, True),
                ("Up", self.scroll,
                 Gtk.ScrollType.STEP_BACKWARD, False, True),
                ("Right", self.scroll,
                 Gtk.ScrollType.STEP_FORWARD, True, True),

                (settings.key_scroll_left_page, self.scroll,
                 Gtk.ScrollType.START, True, False),
                (settings.key_scroll_down_page, self.scroll,
                 Gtk.ScrollType.END, False, False),
                (settings.key_scroll_up_page, self.scroll,
                 Gtk.ScrollType.START, False, False),
                (settings.key_scroll_right_page, self.scroll,
                 Gtk.ScrollType.END, True, False),

                (settings.key_zoom_out, self.zoom_delta, -.25),
                (settings.key_zoom_in, self.zoom_delta, +.25),
                (settings.key_fit, self.zoom_to, 0),
                ("equal", self.zoom_to, self.num_str),
                (settings.key_fit_horiz, self.zoom_to, 0, True, False),
                (settings.key_fit_vert, self.zoom_to, 0, False, True),
                (settings.key_center, self.center_window),

                # Move_index(forward, key, delta=1)
                (settings.key_next_image, self.move_index, True, True),
                (settings.key_prev_image, self.move_index, False, True),
                # Move_pos(forward, key)
                (settings.key_first_image, self.move_pos, False),
                (settings.key_last_image, self.move_pos, True),

                (settings.key_mark, self.mark),
                (settings.key_mark_toggle, self.mark_toggle),

                (settings.key_rotate_clock, self.rotate, 3),
                (settings.key_rotate_cclock, self.rotate, 1),
                (settings.key_rotate_auto, self.rotate_auto),
                (settings.key_fliph, self.flip, True),
                (settings.key_flipv, self.flip, False),
                (settings.key_delete, self.delete, 0),
                (settings.key_edit, self.manipulate_toggle),

                (settings.key_slideshow_inc, self.toggle_slideshow, "inc"),
                (settings.key_slideshow_dec, self.toggle_slideshow, "dec"),

                ("1", self.num_append, "1"),
                ("2", self.num_append, "2"),
                ("3", self.num_append, "3"),
                ("4", self.num_append, "4"),
                ("5", self.num_append, "5"),
                ("6", self.num_append, "6"),
                ("7", self.num_append, "7"),
                ("8", self.num_append, "8"),
                ("9", self.num_append, "9"),
                ("0", self.num_append, "0"),
                )

            self.libbinds = (
                (settings.key_quit, self.quit),
                ("^q", self.quit),

                (settings.key_fullscreen_toggle, self.toggle_fullscreen),
                (settings.key_statusbar_toggle, self.toggle_statusbar),
                (settings.key_library_toggle, self.library_toggle),
                (settings.key_library_toggle_focus, self.library_focus, False),
                (settings.key_rescale_toggle, self.toggle_rescale_svg),
                (settings.key_move_up, self.move_up),

                # if True, scroll in the horizontal direction.
                (settings.key_scroll_left, self.library_scroll, "h", False),
                (settings.key_scroll_down, self.library_scroll, "j", False),
                (settings.key_scroll_up, self.library_scroll, "k", False),
                (settings.key_scroll_right, self.library_scroll, "l", False),
                # Also with the arrow keys
                ("Left", self.library_scroll, "h", True),
                ("Down", self.library_scroll, "j", True),
                ("Up", self.library_scroll, "k", True),
                ("Right", self.library_scroll, "l", True),

                # Resizing
                (settings.key_scroll_left_page, self.resize_lib, False),
                (settings.key_scroll_right_page, self.resize_lib, True),

                # Move_pos(forward, key)
                (settings.key_first_image, self.move_pos_lib, False),
                (settings.key_last_image, self.move_pos_lib, True),

                (settings.key_mark, self.mark_lib),
                (settings.key_delete, self.delete_lib),
                ("i", self.insert_cmd_handler),

                # Some keybindings for the image which don't hurt the library
                (settings.key_zoom_out, self.zoom_delta, -.25),
                (settings.key_zoom_in, self.zoom_delta, +.25),
                (settings.key_fit, self.zoom_to, 0),
                ("equal", self.zoom_to, self.num_str),
                (settings.key_fit_horiz, self.zoom_to, 0, True, False),
                (settings.key_fit_vert, self.zoom_to, 0, False, True),
                (settings.key_center, self.center_window),
                (settings.key_next_image, self.move_index, True, True),
                (settings.key_prev_image, self.move_index, False, True),
                (settings.key_rotate_clock, self.rotate, 3),
                (settings.key_rotate_cclock, self.rotate, 1),
                (settings.key_rotate_auto, self.rotate_auto),
                (settings.key_fliph, self.flip, True),
                (settings.key_flipv, self.flip, False),

                (settings.key_hidden_toggle, self.hidden_toggle),

                ("1", self.num_append, "1"),
                ("2", self.num_append, "2"),
                ("3", self.num_append, "3"),
                ("4", self.num_append, "4"),
                ("5", self.num_append, "5"),
                ("6", self.num_append, "6"),
                ("7", self.num_append, "7"),
                ("8", self.num_append, "8"),
                ("9", self.num_append, "9"),
                ("0", self.num_append, "0"),
                )

            self.cmd_handlerbinds = (
                ("Escape", self.leave_cmd_handler),
                ("^q", self.quit),
                (settings.key_library_toggle_focus, self.library_focus, True),
                (settings.key_cmd_history_up, self.history, False),
                (settings.key_cmd_history_down, self.history, True),
                )

            self.manbinds = (
                (settings.key_quit, self.quit),
                ("^q", self.quit),
                (settings.key_fullscreen_toggle, self.toggle_fullscreen),
                ("Escape", self.button_clicked, "widget", False),
                ("Return", self.button_clicked, "widget", True),
                ("b", self.focus_slider, "bri"),
                ("c", self.focus_slider, "con"),
                ("s", self.focus_slider, "sha"),
                ("h", self.change_slider, True, False),
                ("l", self.change_slider, False, False),
                ("H", self.change_slider, True, True),
                ("L", self.change_slider, False, True),
                ("o", self.button_opt_clicked, "widget"),
                ("1", self.num_append, "1"),
                ("2", self.num_append, "2"),
                ("3", self.num_append, "3"),
                ("4", self.num_append, "4"),
                ("5", self.num_append, "5"),
                ("6", self.num_append, "6"),
                ("7", self.num_append, "7"),
                ("8", self.num_append, "8"),
                ("9", self.num_append, "9"),
                ("0", self.num_append, "0"),
                )

            self.binds = {}
            self.binds["main"] = self.mainbinds
            self.binds["library"] = self.libbinds
            self.binds["cmd_handler"] = self.cmd_handlerbinds
            self.binds["man"] = self.manbinds

        except AttributeError as e:
            print(e)
            print("Reading the config file failed. "
                  "Please refer to the manpage to fix your config.")
            sys.exit(1)

        except ValueError as e:
            print(e)
            print("The type of one of the settings is wrong. "
                  "Please refer to the manpage to fix your config.")
            sys.exit(1)

        Gtk.Window.__init__(self)

    def delete(self, delta=0):
        images = self.manipulated_images("Deleted")
        for i, im in enumerate(images):
            if os.path.isdir(im):
                self.err_message("Deleting directories is not supported")
                break
            index = self.paths.index(im) - i
            self.paths.remove(im)
            if os.path.exists(im):
                deldir = os.path.join(os.path.expanduser("~"), ".vimiv/Trash")
                if not os.path.isdir(deldir):
                    os.mkdir(deldir)
                # Check if there is already a file with that name in the trash
                delfile = deldir + "/" + os.path.basename(im)
                if os.path.exists(delfile):
                    backnum = 1
                    while True:
                        ndelfile = delfile+"."+str(backnum)
                        if not os.path.exists(ndelfile):
                            shutil.move(delfile, ndelfile)
                            break
                        backnum += 1
                shutil.move(im, deldir)
            if not self.paths:
                self.move_up()
                if self.expand_lib:
                    self.grid.set_size_request(self.winsize[0], 10)
                self.err_message("No valid paths, opening library viewer")
            elif self.thumbnail_toggled:
                iter = self.liststore.get_iter(index)
                self.liststore.remove(iter)
            else:
                self.move_index(True, False, delta)
        self.marked = []

    def quit(self):
        for image in self.marked:
            print(image)
        # Remove the "EDIT" Thumbnails if the user quits in manipulate mode
        if self.paths and "EDIT" in self.paths[self.index]:
            self.button_clicked(False)

        Gtk.main_quit()

    def scroll(self, scrolltype, horizontal, arrow_key):
        """ Scroll the correct object """
        if self.thumbnail_toggled:
            self.thumbnail_move(scrolltype, horizontal, arrow_key)
        else:
            self.scrolled_win.emit('scroll-child', scrolltype, horizontal)

    def library_scroll(self, direction, arrow_key):
        """ Scroll the library viewer and select if necessary """
        # Handle the specific keys
        if direction == "h":  # Behave like ranger
            self.remember_pos(os.path.abspath("."), self.treepos)
            self.move_up()
        elif direction == "l":
            self.file_select("a", Gtk.TreePath(self.treepos), "b", False)
        else:
            # Scroll the tree with jk checking for a user step
            if self.num_str and not arrow_key:  # arrow keys dont work yet
                step = int(self.num_str)
            else:
                step = 1
            if direction == "j":
                if self.treepos < len(self.filelist)-step:
                    self.treepos += step
            else:
                if self.treepos > step-1:
                    self.treepos -= step

            # Necessary because Gtk moves with the arrows anyway
            if not arrow_key:
                self.treeview.set_cursor(Gtk.TreePath(self.treepos),
                                         None, False)
            # Clear the user prefixed step
            self.num_clear()

    def thumbnail_move(self, scrolltype, horizontal, arrow_key):
        """ Select thumbnails correctly and scroll """
        # Check for a user prefixed step
        if self.num_str:
            step = int(self.num_str)
        else:
            step = 1
        # Check for the specified thumbnail and handle exceptons
        if scrolltype == Gtk.ScrollType.STEP_BACKWARD and horizontal:
            self.thumbpos[0] -= step
            if self.thumbpos[0] < 0:
                self.thumbpos[0] += step
                step = 0  # Do not scroll
        elif scrolltype == Gtk.ScrollType.STEP_BACKWARD:
            self.thumbpos[0] -= self.columns*step
            if self.thumbpos[0] < 0:
                self.thumbpos[0] += self.columns*step
                step = 0
        elif scrolltype == Gtk.ScrollType.STEP_FORWARD and horizontal:
            self.thumbpos[0] += step
            if self.thumbpos[0] == len(self.paths):
                self.thumbpos[0] -= step
                step = 0
        else:
            self.thumbpos = [self.thumbpos[0] + self.columns*step]
            if self.thumbpos[0] >= len(self.paths):
                self.thumbpos[0] -= self.columns*step
                step = 0
        # Move
        path = Gtk.TreePath.new_from_indices(self.thumbpos)
        if not arrow_key:
            self.iconview.select_path(path)
            curthing = self.iconview.get_cells()[0]
            self.iconview.set_cursor(path, curthing, False)
        # Actual scrolling
        self.thumbnail_scroll(scrolltype, horizontal, step,
                              self.thumbpos[0])
        # Clear the user prefixed step
        self.num_clear()

    def thumbnail_scroll(self, scrolltype, horizontal, step, target):
        """ Handles the actual scrolling """
        # TODO
        if step == 0:
            step += 1
        # Vertical
        if not horizontal:
            Gtk.Adjustment.set_step_increment(
                self.viewport.get_vadjustment(), self.thumbsize[1]*step)
            self.scrolled_win.emit('scroll-child', scrolltype, False)
        # Horizontal (tricky because one might reach a new column)
        else:
            if step == 1:
                if ((self.thumbpos[0] % self.columns == 0 and
                     scrolltype == Gtk.ScrollType.STEP_FORWARD) or
                    (self.thumbpos[0] % self.columns == self.columns-1 and
                     scrolltype == Gtk.ScrollType.STEP_BACKWARD)):
                    self.scrolled_win.emit('scroll-child', scrolltype, False)
            else:
                start = target - step
                startcol = int(start / self.columns)
                endcol = int(target / self.columns)
                toscroll = endcol - startcol
                Gtk.Adjustment.set_step_increment(
                    self.viewport.get_vadjustment(), self.thumbsize[1]*toscroll)
                self.scrolled_win.emit('scroll-child', scrolltype, False)

    def toggle_slideshow(self, key=""):
        """ Toggles the slideshow or updates the delay """
        if not self.paths:
            self.err_message("No valid paths, starting slideshow failed")
            return
        if self.thumbnail_toggled:
            self.err_message("Slideshow makes no sense in thumbnail mode")
            return
        update = False
        if key == "dec":
            if self.slideshow_delay >= 0.8:
                self.slideshow_delay -= 0.2
            update = True
        elif key == "inc":
            self.slideshow_delay += 0.2
            update = True
        elif self.num_str:
            if self.num_str[0] != "0":
                self.slideshow_delay = float(self.num_str)
            self.num_str = ""
            update = True
        # If the delay wasn't changed in any way just toggle the slideshow
        else:
            self.slideshow = not self.slideshow
            if self.slideshow:
                self.timer_id_s = GLib.timeout_add(1000*self.slideshow_delay,
                                                   self.move_index, True,
                                                   False, 1)
            else:
                GLib.source_remove(self.timer_id_s)
        # But if the delay was changed reload the timer with the new delay
        if update and self.slideshow:
            GLib.source_remove(self.timer_id_s)
            self.timer_id_s = GLib.timeout_add(1000*self.slideshow_delay,
                                               self.move_index, True, False, 1)
        self.update_info()

    def err_message(self, mes):
        """ Pushes an error message to the statusbar """
        self.error.append(1)
        mes = "<b>" + mes + "</b>"
        self.timer_id = GLib.timeout_add_seconds(5, self.error_false)
        if not self.sbar:
            self.left_label.set_markup(mes)
        else:  # Show bar if it isn't there
            self.toggle_statusbar()
            self.left_label.set_markup(mes)
            self.timer_id = GLib.timeout_add_seconds(5, self.toggle_statusbar)

    def error_false(self):
        self.error = self.error[0:-1]
        if not self.error:
            self.update_info()

    def toggle_fullscreen(self):
        self.fullscreen = not self.fullscreen
        if self.fullscreen:
            self.win.fullscreen()
        else:
            self.win.unfullscreen()
        # Adjust the image if necessary
        if self.paths:
            if self.user_zoomed:
                self.update_image()
            else:
                self.zoom_to(0)

    def toggle_statusbar(self):
        if not self.sbar:
            self.labelbox.hide()
        else:
            self.labelbox.show()
        self.sbar = not self.sbar
        # Resize the image if necessary
        if not self.user_zoomed and self.paths and not self.thumbnail_toggled:
            self.zoom_to(0)

    def toggle_rescale_svg(self):
        self.rescale_svg = not self.rescale_svg

    def manipulated_images(self, message):
        """ Returns the images which should be manipulated - either the
            currently focused one or all marked images """
        images = []
        # Add the image shown
        if not self.marked and not self.thumbnail_toggled:
            images.append(self.paths[self.index])
        # Add all marked images
        else:
            images = self.marked
            if len(images) == 1:
                err = "%s %d marked image" % (message, len(images))
            else:
                err = "%s %d marked images" % (message, len(images))
            self.err_message(err)
        # Delete all thumbnails of manipulated images
        thumbdir = os.path.join(os.path.expanduser("~"), ".vimiv/Thumbnails")
        p = Popen(['ls', thumbdir], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        thumbnails, err = p.communicate()
        thumbnails = thumbnails.decode(encoding='UTF-8')
        for im in images:
            thumb = im.split(".")[0] + ".thumbnail" + ".png"
            thumb = thumb.split("/")[-1]
            if thumb in thumbnails:
                thumb = os.path.join(thumbdir, thumb)
                shutil.os.remove(thumb)

        return images

    def rotate(self, cwise):
        try:
            images = self.manipulated_images("Rotated")
            # Rotate the image shown
            if self.paths[self.index] in images:
                self.pixbufOriginal = self.pixbufOriginal.rotate_simple(
                    (90 * cwise))
                self.update_image(False)
            # Rotate all files
            for image in images:
                im = Image.open(image)
                if cwise == 3:
                    im = im.transpose(Image.ROTATE_270)
                else:
                    im = im.transpose(Image.ROTATE_90)
                im.save(image)
                if self.thumbnail_toggled:
                    self.thumb_reload(image, self.paths.index(image))

        except:
            self.err_message("Warning: Object cannot be rotated")

    def flip(self, dir):
        try:
            images = self.manipulated_images("Flipped")
            # Flip the image shown
            if self.paths[self.index] in images:
                self.pixbufOriginal = self.pixbufOriginal.flip(dir)
                self.update_image(False)
            # Flip all files
            for image in images:
                im = Image.open(image)
                if dir:
                    im = im.transpose(Image.FLIP_LEFT_RIGHT)
                else:
                    im = im.transpose(Image.FLIP_TOP_BOTTOM)
                im.save(image)
                if self.thumbnail_toggled:
                    self.thumb_reload(image, self.paths.index(image))

        except:
            self.err_message("Warning: Object cannot be flipped")

    def rotate_auto(self):
        """ This function autorotates all pictures in the current pathlist """
        rotated_images = 0
        # ImageMagick does this better
        try:
            cmd = ["jhead", "-autorot", "-ft"] + self.paths
            p = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
            out, err = p.communicate()
            out = out.decode(encoding='UTF-8')
            err = err.decode(encoding='UTF-8')
            # Find out how many images were rotated
            for line in out.split("\n"):
                if "Modified" in line and line.split()[1] not in err:
                    rotated_images += 1
            # Added to the message displayed when done
            method = "ImageMagick"
        # If it isn't there fall back to PIL
        except:
            for path in self.paths:
                im = Image.open(path)
                exif = im._getexif()

                orientation_key = 274  # cf ExifTags
                rotated = True

                # Only do something if orientation info is there
                if exif and orientation_key in exif:
                    orientation = exif[orientation_key]

                    # Rotate and save the image
                    if orientation == 3:
                        im = im.transpose(Image.ROTATE_180)
                    elif orientation == 6:
                        im = im.transpose(Image.ROTATE_270)
                    elif orientation == 8:
                        im = im.transpose(Image.ROTATE_90)
                    else:
                        rotated = False
                    if rotated:
                        im.save(path, quality=100)
                        rotated_images += 1
                method = "PIL"
        # Reload current image and display a message if something was done
        if rotated_images:
            self.move_index(True, False, 0)
            message = "Autorotated %d image(s) using %s." % (rotated_images,
                                                             method)
        else:
            message = "No image rotated."
        self.err_message(message)

    def manipulate(self):
        """ Starts a window with basic image manipulation """
        # A vbox in which everything gets packed
        self.hboxman = Gtk.HBox(spacing=5)
        self.hboxman.connect("key_press_event", self.handle_key_press, "man")

        # A list to save the changes being done
        self.manipulations = [1, 1, 1, False]

        # Sliders
        self.scale_bri = Gtk.HScale()
        self.scale_bri.connect("value-changed", self.value_slider, "bri")
        self.scale_con = Gtk.HScale()
        self.scale_con.connect("value-changed", self.value_slider, "con")
        self.scale_sha = Gtk.HScale()
        self.scale_sha.connect("value-changed", self.value_slider, "sha")

        # Set some properties
        for scale in [self.scale_bri, self.scale_con, self.scale_sha]:
            scale.set_range(-127, 127)
            scale.set_size_request(120, 20)
            scale.set_value(0)
            scale.set_digits(0)

        # Labels
        bri_label = Gtk.Label()
        bri_label.set_markup("\n<b>Bri</b>")
        con_label = Gtk.Label()
        con_label.set_markup("\n<b>Con</b>")
        sha_label = Gtk.Label()
        sha_label.set_markup("\n<b>Sha</b>")

        # Buttons
        button_yes = Gtk.Button(label="Accept")
        button_yes.connect("clicked", self.button_clicked, True)
        button_yes.set_size_request(80, 20)
        button_no = Gtk.Button(label="Cancel")
        button_no.connect("clicked", self.button_clicked, False)
        button_no.set_size_request(80, 20)
        button_opt = Gtk.Button(label="Optimize")
        button_opt.connect("clicked", self.button_opt_clicked)
        button_opt.set_size_request(80, 20)

        # Pack everything into the box
        self.hboxman.add(bri_label)
        self.hboxman.add(self.scale_bri)
        self.hboxman.add(con_label)
        self.hboxman.add(self.scale_con)
        self.hboxman.add(sha_label)
        self.hboxman.add(self.scale_sha)
        self.hboxman.add(button_opt)
        self.hboxman.add(button_yes)
        self.hboxman.add(button_no)

    def manipulate_toggle(self):
        if self.manipulate_toggled:
            self.manipulate_toggled = False
            self.hboxman.hide()
            self.scrolled_win.grab_focus()
            self.update_info()
        elif self.paths and not self.thumbnail_toggled:
            try:
                self.pixbufOriginal.is_static_image()
                self.err_message("Manipulating Gifs is not supported")
            except:
                self.manipulate_toggled = True
                self.hboxman.show()
                self.scale_bri.grab_focus()
                self.update_info()
        else:
            if self.thumbnail_toggled:
                self.err_message("Manipulate not supported in thumbnail mode")
            else:
                self.err_message("No image open to edit")

    def manipulate_image(self, real=""):
        """ Apply the actual changes defined by the following actions """
        if real:  # To the actual image?
            orig, out = real, real
        # A thumbnail for higher responsiveness
        elif "-EDIT" not in self.paths[self.index]:
            im = Image.open(self.paths[self.index])
            out = self.paths[self.index].replace(".", "-EDIT.")
            orig = out.replace("EDIT", "EDIT-ORIG")
            im.thumbnail(self.imsize, Image.ANTIALIAS)
            im.save(out)
            self.paths[self.index] = out
            # Save the original to work with
            im.save(orig)
        else:
            out = self.paths[self.index]
            orig = out.replace("EDIT", "EDIT-ORIG")
        # Apply all manipulations
        if self.manipulations[3]:  # Optimize
            try:
                call(["mogrify", "-contrast", "-auto-gamma", "-auto-level",
                     orig])
            except:
                err = "Optimize exited with status 1, is imagemagick installed?"
                self.err_message(err)
        im = Image.open(orig)
        # Enhance all three values
        im = ImageEnhance.Brightness(im).enhance(self.manipulations[0])
        im = ImageEnhance.Contrast(im).enhance(self.manipulations[1])
        im = ImageEnhance.Sharpness(im).enhance(self.manipulations[2])
        # Write
        im.save(out, "JPEG")

        # Show the edited image
        self.image.clear()
        self.pixbufOriginal = GdkPixbuf.PixbufAnimation.new_from_file(out)
        self.pixbufOriginal = self.pixbufOriginal.get_static_image()
        if not self.fullscreen:
            self.imsize = self.image_size()
        self.zoom_percent = self.get_zoom_percent()
        self.update_image()

    def value_slider(self, w, name, reset=False):
        """ Function for the brightness/contrast sliders """
        val = w.get_value()
        if val != 0:  # Necessary to be able to reset values
            val = (val + 127) / 127
            # Change brightness, contrast or sharpness
            if name == "bri":
                self.manipulations[0] = val
            elif name == "con":
                self.manipulations[1] = val
            else:
                self.manipulations[2] = val
            # Run the manipulation function
            self.manipulate_image()

    def focus_slider(self, man):
        """ Focuses one of the three sliders """
        if man == "bri":
            self.scale_bri.grab_focus()
        elif man == "con":
            self.scale_con.grab_focus()
        else:
            self.scale_sha.grab_focus()

    def change_slider(self, dec, large):
        """ Changes the value of the currently focused slider """
        for scale in [self.scale_bri, self.scale_con, self.scale_sha]:
            if scale.is_focus():
                val = scale.get_value()
                if self.num_str:
                    step = int(self.num_str)
                    self.num_str = ""
                    if dec:
                        val -= step
                    else:
                        val += step
                elif dec and large:
                    val -= 10
                elif dec:
                    val -= 1
                elif not dec and large:
                    val += 10
                else:
                    val += 1
                scale.set_value(val)
                break

    def button_clicked(self, widget, accept=False):
        """ Finishes manipulate mode """
        if "EDIT" in self.paths[self.index]:
            # Remove the thumbnail files used
            out = self.paths[self.index]
            orig = out.replace("EDIT", "EDIT-ORIG")
            os.remove(out)
            os.remove(orig)
            self.paths[self.index] = out.replace("-EDIT", "")
            # Edit the actual file if yes
            if accept:
                self.manipulate_image(self.paths[self.index])
            # Show the original image
            self.image.clear()
            self.pixbufOriginal = GdkPixbuf.PixbufAnimation.new_from_file(
                self.paths[self.index])
            self.pixbufOriginal = self.pixbufOriginal.get_static_image()
            if not self.fullscreen:
                self.imsize = self.image_size()
            self.zoom_percent = self.get_zoom_percent()
            self.update_image()
        else:
            self.err_message("No changes made")
        # Reset all the manipulations
        self.manipulations = [1, 1, 1, False]
        for scale in [self.scale_bri, self.scale_con, self.scale_sha]:
            scale.set_value(0)
        # Done
        self.manipulate_toggle()
        self.update_info()

    def button_opt_clicked(self, widget):
        """ Sets optimize to True and runs the manipulation """
        self.manipulations[3] = True
        self.manipulate_image()

    def animation_toggle(self):
        if self.paths and not self.thumbnail_toggled:
            self.animation_toggled = not self.animation_toggled
            self.update_image()

    def thumbnails(self):
        imlist = list()

        # Thumbnail directory and all thumbnails in there
        thumbdir = os.path.join(os.path.expanduser("~"), ".vimiv/Thumbnails")
        p = Popen(['ls', thumbdir], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        thumbnails, err = p.communicate()
        thumbnails = thumbnails.decode(encoding='UTF-8')

        # Create thumbnail directory if necessary
        if not os.path.isdir(thumbdir):
            os.mkdir(thumbdir)

        self.errorpos = []  # Catch errors to focus images correctly later
        # Create thumbnails for all images in the path
        for i, infile in enumerate(self.paths):
            outfile = ".".join(infile.split(".")[:-1]) + ".thumbnail" + ".png"
            outfile = outfile.split("/")[-1]
            outfile = os.path.join(thumbdir, outfile)
            # Only if they aren't cached already
            if outfile.split("/")[-1] not in thumbnails:
                try:
                    im = Image.open(infile)
                    im.thumbnail(self.thumbsize, Image.ANTIALIAS)
                    im.save(outfile, "PNG")
                    imlist.append(outfile)
                except:
                    err = "Error: thumbnail creation for " + outfile + " failed"
                    self.err_message(err)
                    self.errorpos.append(i)
            else:
                imlist.append(outfile)

        # Create the liststore and iconview
        self.liststore = Gtk.ListStore(GdkPixbuf.Pixbuf, str)
        self.iconview = Gtk.IconView.new()
        self.iconview.connect("item-activated", self.iconview_clicked)
        self.iconview.set_model(self.liststore)
        self.columns = int(self.imsize[0]/(self.thumbsize[0]+100))
        self.iconview.set_columns(self.columns)
        self.iconview.set_column_spacing(0)
        self.iconview.set_row_spacing(0)
        self.iconview.set_item_width(self.thumbsize[0])
        self.iconview.set_pixbuf_column(0)
        self.iconview.set_border_width(1)
        self.iconview.set_markup_column(1)

        # Add all thumbnails to the liststore
        for i, thumb in enumerate(imlist):
            pixbuf = GdkPixbuf.Pixbuf.new_from_file(thumb)
            name = thumb.split("/")[-1].split(".")[0]
            if self.paths[i] in self.marked:
                name = name + " [*]"
            self.liststore.append([pixbuf, name])

        # Draw the icon view instead of the image
        self.viewport.remove(self.image)
        self.viewport.add(self.iconview)
        # Show the window
        self.iconview.show()
        self.thumbnail_toggled = True
        # Focus the current immage
        self.iconview.grab_focus()
        self.thumbpos = [(self.index) % len(self.paths)]
        for i in self.errorpos:
            if self.thumbpos[0] > i:
                self.thumbpos[0] -= 1
        curpath = Gtk.TreePath.new_from_indices(self.thumbpos)
        self.iconview.select_path(curpath)
        curthing = self.iconview.get_cells()[0]
        self.iconview.set_cursor(curpath, curthing, False)

    def iconview_clicked(self, w, count):
        # Move to the current position if the iconview is clicked
        self.thumbnail_toggle()
        count = count.get_indices()[0] + 1
        self.num_clear()
        for i in self.errorpos:
            if count > i:
                count += 1
        self.num_str = str(count)
        self.move_pos()

    def thumbnail_toggle(self):
        if self.thumbnail_toggled:
            self.viewport.remove(self.iconview)
            self.viewport.add(self.image)
            self.update_image()
            self.scrolled_win.grab_focus()
            self.thumbnail_toggled = False
        elif self.paths:
            self.thumbnails()
            self.timer_id = GLib.timeout_add(1, self.scroll_to_thumb)
            if self.library_focused:
                self.treeview.grab_focus()
            if self.manipulate_toggled:
                self.manipulate_toggle()
        else:
            self.err_message("No open image")
        # Update info for the current mode
        self.update_info()

    def thumb_reload(self, thumb, index):
        """ Reloads the thumbnail of manipulated images """
        for i in self.errorpos:
            if index > i:
                index -= 1
        iter = self.liststore.get_iter(index)
        self.liststore.remove(iter)
        try:
            outfile = thumb.split(".")[0] + ".thumbnail" + ".png"
            outfile = outfile.split("/")[-1]
            thumbdir = os.path.join(os.path.expanduser("~"),
                                    ".vimiv/Thumbnails")
            outfile = os.path.join(thumbdir, outfile)
            im = Image.open(thumb)
            im.thumbnail(self.thumbsize)
            im.save(outfile, "PNG")
            pixbuf = GdkPixbuf.Pixbuf.new_from_file(outfile)
            name = outfile.split("/")[-1].split(".")[0]
            if thumb in self.marked:
                name = name + " [*]"
            self.liststore.insert(index, [pixbuf, name])
            path = Gtk.TreePath.new_from_indices(self.thumbpos)
            self.iconview.select_path(path)
            curthing = self.iconview.get_cells()[0]
            self.iconview.set_cursor(path, curthing, False)
        except:
            self.err_message("Reload of manipulated thumbnails failed ")

    def name_reload(self, name, index, mark=True):
        """ Reloads the name of marked thumbnails """
        for i in self.errorpos:  # Images where thumbnail creation failed
            if index > i:
                index -= 1
        # Remove the old thumbnail
        iter = self.liststore.get_iter(index)
        self.liststore.remove(iter)
        try:
            # Recreate the thumbnail
            outfile = name.split(".")[0] + ".thumbnail" + ".png"
            outfile = outfile.split("/")[-1]
            thumbdir = os.path.join(os.path.expanduser("~"),
                                    ".vimiv/Thumbnails")
            outfile = os.path.join(thumbdir, outfile)
            pixbuf = GdkPixbuf.Pixbuf.new_from_file(outfile)
            name = name.split("/")[-1].split(".")[0]
            if mark:
                name = name + " [*]"
            # Insert it
            self.liststore.insert(index, [pixbuf, name])
            # Set the cursor back to where it was
            path = Gtk.TreePath.new_from_indices(self.thumbpos)
            self.iconview.select_path(path)
            curthing = self.iconview.get_cells()[0]
            self.iconview.set_cursor(path, curthing, False)
        except:
            self.err_message("Reload of (un)marked thumbnails failed")

    def scroll_to_thumb(self):
        """ Function which scrolls to the currently selected thumbnail """
        # TODO
        scrollamount = int(self.thumbpos[0] / self.columns) * self.thumbsize[1]
        Gtk.Adjustment.set_step_increment(
            self.viewport.get_vadjustment(), scrollamount)
        self.scrolled_win.emit('scroll-child',
                               Gtk.ScrollType.STEP_FORWARD, False)

    def get_zoom_percent(self, zWidth=False, zHeight=False):
        """ returns the current zoom factor """
        # Size of the file
        pboWidth = self.pixbufOriginal.get_width()
        pboHeight = self.pixbufOriginal.get_height()
        pboScale = pboWidth / pboHeight
        # Size of the image to be shown
        wScale = self.imsize[0] / self.imsize[1]

        stickout = zWidth | zHeight
        # Image is completely shown
        if pboWidth < self.imsize[0] and pboHeight < self.imsize[1] and not stickout:
            return 1
        # Vertical proportions relevant
        elif (pboScale < wScale and not stickout) or zHeight:
            return self.imsize[1] / pboHeight
        # Horizontal proportions relevant
        else:
            return self.imsize[0] / pboWidth

    def update_image(self, update_info=True):
        """ Show the final image """
        if not self.paths:
            return
        pboWidth = self.pixbufOriginal.get_width()
        pboHeight = self.pixbufOriginal.get_height()

        try:  # If possible scale the image
            """ In fullscreen, always scale to max width/height,
            (depending on image ratio vs screen ratio), except if user zoomed
            image manually (Note: untested in multi-monitor/multi-screen
            environments """

            if self.fullscreen and not self.user_zoomed:
                imgRatio = pboWidth / pboHeight
                scrRatio = self.screensize[0] / self.screensize[1]

                if imgRatio > scrRatio:
                    # "panorama/landscape" image: Scale to Height
                    factor = self.screensize[0] / pboWidth
                    pbfWidth = self.screensize[0]
                    pbfHeight = int(pboHeight * factor)
                else:
                    # "portrait" image: Scale to width
                    factor = self.screensize[1] / pboHeight
                    pbfHeight = self.screensize[1]
                    pbfWidth = int(pboWidth * factor)
                self.zoom_percent = pbfHeight / pboHeight;
            else:
                pbfWidth = int(pboWidth * self.zoom_percent)
                pbfHeight = int(pboHeight * self.zoom_percent)

            # Rescaling of svg
            ending = self.paths[self.index].split("/")[-1].split(".")[-1]
            if ending == "svg" and self.rescale_svg:
                pixbufFinal = GdkPixbuf.Pixbuf.new_from_file_at_scale(
                    self.paths[self.index], -1, pbfHeight, True)
            else:
                pixbufFinal = self.pixbufOriginal.scale_simple(
                    pbfWidth, pbfHeight, GdkPixbuf.InterpType.BILINEAR)
            self.image.set_from_pixbuf(pixbufFinal)
        except:  # If not it must me an animation
            # TODO actual pause and play of Gifs
            if not self.animation_toggled:
                self.image.set_from_animation(self.pixbufOriginal)
            else:
                pixbufFinal = self.pixbufOriginal.get_static_image()
                self.image.set_from_pixbuf(pixbufFinal)
        # Update the statusbar if required
        if update_info:
            self.update_info()

    def update_info(self):
        """ Update the statusbar and the window title """
        # Left side
        try:
            # Directory if library is focused
            if self.library_focused:
                self.left_label.set_text(os.path.abspath("."))
            # Position, name and thumbnail size in thumb mode
            elif self.thumbnail_toggled:
                name = self.paths[self.thumbpos[0]].split("/")[-1]
                message = "{0}/{1}  {2}  {3}".format(self.thumbpos[0]+1,
                    len(self.paths), name, self.thumbsize)
                self.left_label.set_text(message)
            # Image info in image mode
            else:
                name = self.paths[self.index].split("/")[-1]
                message = "{0}/{1}  {2}  [{3:.0f}%]".format(self.index+1,
                    len(self.paths), name, self.zoom_percent*100)
                self.left_label.set_text(message)
        except:
            self.left_label.set_text("No open images")
        # Center
        if not (self.thumbnail_toggled or self.library_focused) and self.paths:
            mark = "[*]" if self.paths[self.index] in self.marked else ""
        else:
            mark = ""
        if self.slideshow:
            slideshow = "[slideshow - {0:.1f}s]".format(self.slideshow_delay)
        else:
            slideshow = ""
        message = "{0}  {1}".format(mark, slideshow)
        self.center_label.set_text(message)
        # Right side
        mode = self.get_mode()
        message = "{0:15}  {1:4}".format(mode, self.num_str)
        self.right_label.set_markup(message)
        # Window title
        try:
            name = self.paths[self.index].split("/")[-1]
            self.win.set_title("vimiv - "+name)
        except:
            self.win.set_title("vimiv")
        # Size of statusbar for resizing image
        self.statusbar_size = self.labelbox.get_allocated_height()

    def get_mode(self):
        """ Returns which widget is currently focused """
        if self.library_focused:
            # Additionally show the current library directory
            return "<b>-- LIBRARY --</b>"
        elif self.manipulate_toggled:
            return "<b>-- MANIPULATE --</b>"
        elif self.thumbnail_toggled:
            return "<b>-- THUMBNAIL --</b>"
        else:
            return "<b>-- IMAGE --</b>"

    def set_default_window_size(self):
        """ Sets the window size at the beginning """
        try:
            self.winsize = (int(self.geometry.split("x")[0]),
                            int(self.geometry.split("x")[1]))
        except:
            print("Must be a correct geometry in the form of "
                  "800x600, falling back to default")
            self.winsize = (800, 600)
        self.win.resize(self.winsize[0], self.winsize[1])

        if self.fullscreen:
            self.win.fullscreen()

    def image_size(self):
        """ Returns the size of the image depending on what other widgets
        are visible and if fullscreen or not """
        if self.fullscreen:
            size = self.screensize
        else:
            size = self.win.get_size()
        if self.library_toggled:
            size = (size[0] - self.library_width, size[1])
        if not self.sbar:
            size = (size[0], size[1] - self.statusbar_size - 16)
        return size

    def zoom_delta(self, delta):
        """ Zooms the image by delta percent """
        if self.thumbnail_toggled:
            return
        self.user_zoomed = True
        try:
            self.zoom_percent = self.zoom_percent * (1 + delta)
            # Catch some unreasonable zooms
            if (self.pixbufOriginal.get_height()*self.zoom_percent < 5 or
                    self.pixbufOriginal.get_height()*self.zoom_percent >
                    self.screensize[0]*5):
                self.zoom_percent = self.zoom_percent / (1 + delta)
                raise ValueError
            self.update_image()
        except:
            self.err_message("Warning: Object cannot be zoomed (further)")

    def zoom_to(self, percent, zWidth=False, zHeight=False):
        """ Zooms to a given percentage """
        if self.thumbnail_toggled:
            return
        before = self.zoom_percent
        self.user_zoomed = False
        # Catch user zooms
        if self.num_str:
            self.user_zoomed = True
            percent = self.num_str
            # If prefixed with a zero invert value
            try:
                if percent[0] == "0":
                    percent = 1/float(percent[1:])
                else:
                    percent = float(percent)
            except:
                self.err_message("Error: Zoom percentage not parseable")
                return
            self.num_str = ""
        try:
            self.imsize = self.image_size()
            self.zoom_percent = percent if percent else self.get_zoom_percent(
                zWidth,
                zHeight)
            # Catch some unreasonable zooms
            if (self.pixbufOriginal.get_height()*self.zoom_percent < 5 or
                    self.pixbufOriginal.get_height()*self.zoom_percent >
                    self.screensize[0]*5):
                self.zoom_percent = before
                raise ValueError
            self.update_image()
        except:
            self.err_message("Warning: Object cannot be zoomed (further)")

    def center_window(self):
        """ Centers the image in the current window """
        # Don't do anything if no images are open
        if not self.paths or self.thumbnail_toggled:
            return
        # Vertical
        pboHeight = self.pixbufOriginal.get_height()
        vadj = self.viewport.get_vadjustment().get_value()
        vact = self.zoom_percent * pboHeight
        diff = vact - self.imsize[1]
        if diff > 0:
            toscroll = (diff - 2*vadj) / 2
            Gtk.Adjustment.set_step_increment(
                self.viewport.get_vadjustment(), toscroll)
            self.scrolled_win.emit('scroll-child',
                                   Gtk.ScrollType.STEP_FORWARD, False)
            # Reset scrolling
            Gtk.Adjustment.set_step_increment(self.viewport.get_vadjustment(),
                                              100)
        # Horizontal
        pboWidth = self.pixbufOriginal.get_width()
        hadj = self.viewport.get_hadjustment().get_value()
        hact = self.zoom_percent * pboWidth
        if diff > 0:
            diff = hact - self.imsize[0]
            toscroll = (diff - 2*hadj) / 2
            Gtk.Adjustment.set_step_increment(
                self.viewport.get_hadjustment(), toscroll)
            self.scrolled_win.emit('scroll-child',
                                   Gtk.ScrollType.STEP_FORWARD, True)
            # Reset scrolling
            Gtk.Adjustment.set_step_increment(self.viewport.get_hadjustment(),
                                              100)

    def move_index(self, forward=True, key=False, delta=1):
        """ Move by delta in the path """
        # Check if an image is opened
        if not self.paths or self.thumbnail_toggled:
            return
        # Check for prepended numbers
        if key and self.num_str:
            delta *= int(self.num_str)
        # Forward or backward
        if not forward:
            delta *= -1
        self.index = (self.index + delta) % len(self.paths)
        self.user_zoomed = False

        # Reshuffle on wrap-around
        if self.shuffle and self.index is 0 and delta > 0:
            shuffle(self.paths)

        path = self.paths[self.index]
        try:
            if not os.path.exists(path):
                print("Error: Couldn't open", path)
                self.delete()
                return
            else:
                self.pixbufOriginal = GdkPixbuf.PixbufAnimation.new_from_file(
                    path)
            if self.pixbufOriginal.is_static_image():
                self.pixbufOriginal = self.pixbufOriginal.get_static_image()
                self.imsize = self.image_size()
                self.zoom_percent = self.get_zoom_percent()
            else:
                self.zoom_percent = 1
            # If one simply reloads the file the info shouldn't be updated
            if delta:
                self.update_image()
            else:
                self.update_image(False)

        except GLib.Error:  # File not accessible
            self.paths.remove(path)
            self.err_message("Error: file not accessible")
            self.move_pos(False)

        self.num_clear()
        return True  # for the slideshow

    def move_pos(self, forward=True):
        """ Move to pos in path """
        max = len(self.paths)
        if self.thumbnail_toggled:
            current = self.thumbpos[0] % len(self.paths)
            max = max - len(self.errorpos)
        else:
            current = (self.index) % len(self.paths)
        # Move to definition by keys or end/beg
        if self.num_str:
            pos = int(self.num_str)
        elif forward:
            pos = max
        else:
            pos = 1
        # Catch exceptions
        try:
            current = int(current)
            max = int(max)
            if pos < 0 or pos > max:
                raise ValueError
        except:
            self.err_message("Warning: Unsupported index")
            return False
        # Do the math and move
        dif = pos - current - 1
        if self.thumbnail_toggled:
            pos -= 1
            self.thumbpos[0] = pos
            path = Gtk.TreePath.new_from_indices([pos])
            self.iconview.select_path(path)
            curthing = self.iconview.get_cells()[0]
            self.iconview.set_cursor(path, curthing, False)
            if forward:
                self.scrolled_win.emit('scroll-child',
                                       Gtk.ScrollType.END, False)
            else:
                self.scrolled_win.emit('scroll-child',
                                       Gtk.ScrollType.START, False)
        else:
            self.move_index(True, False, dif)
            self.user_zoomed = False

        self.num_clear()
        return True

    def num_append(self, num):
        """ Adds a new char to the num_str """
        self.num_str += num
        self.timer_id = GLib.timeout_add_seconds(1, self.num_clear)
        self.update_info()

    def num_clear(self):
        """ Clears the num_str """
        self.num_str = ""
        self.update_info()

    def populate(self, args, start=False):
        """ Generate a list of paths from the given arguments """

        # If only one path is passed do special stuff
        single = None
        if len(args) == 1:
            arg = args[0]
            if os.path.islink(arg):
                arg = os.path.realpath(arg)
            if os.path.isfile(arg):
                # Use parent directory
                single = os.path.abspath(arg)
                directory = os.path.dirname(single)
                args = self.filelist_create(directory)
                for i, arg in enumerate(args):
                    args[i] = os.path.join(directory, arg)
            elif os.path.isdir(arg):
                # Open dir in library browser
                self.move_up(arg, True)
                return 0

        # Add everything
        for arg in args:
            path = os.path.abspath(arg)
            if os.path.isfile(path):
                self.paths.append(path)
            elif os.path.isdir(path) and self.recursive:
                paths = sorted([os.path.join(path, x)
                                for x in os.listdir(path)])
                self.paths.extend(paths)
        # Remove unsupported files
        self.paths = [possible_path for possible_path in self.paths
                      if mimetypes.guess_type(possible_path)[0] in self.types]

        # Shuffle
        if self.shuffle:
            shuffle(self.paths)

        # Complete special stuff for single arg
        if single and single in self.paths:
            self.index = self.paths.index(single)
        else:
            self.index = 0

        # Show the image as soon as possible
        if self.paths and not start:
            self.grid.set_size_request(self.library_width-self.border_width, 10)
            self.scrolled_win.show()

        return len(self.paths)

    def mark(self):
        """ Marks the current image """
        if self.thumbnail_toggled:
            index = self.thumbpos[0]
            pathindex = index
            for i in self.errorpos:
                if pathindex >= i:
                    pathindex += 1
            if self.paths[pathindex] in self.marked:
                self.marked.remove(self.paths[pathindex])
                self.name_reload(self.paths[pathindex], index, False)
            else:
                self.marked.append(self.paths[pathindex])
                self.name_reload(self.paths[pathindex], index)

        else:
            if self.paths[self.index] in self.marked:
                self.marked.remove(self.paths[self.index])
            else:
                self.marked.append(self.paths[self.index])
        self.marked_bak = []
        self.update_info()

    def mark_toggle(self):
        if self.marked:
            self.marked_bak = self.marked
            self.marked = []
        else:
            self.marked, self.marked_bak = self.marked_bak, self.marked
        self.update_info()

    def library(self):
        """ Starts the library browser """
        # Librarybox
        self.boxlib = Gtk.HBox()
        # Set up the self.grid in which the file info will be positioned
        self.grid = Gtk.Grid()
        self.grid.set_column_homogeneous(True)
        self.grid.set_row_homogeneous(True)
        if self.paths or not self.expand_lib:
            self.grid.set_size_request(self.library_width-self.border_width, 10)
        else:
            self.grid.set_size_request(self.winsize[0], 10)
        # A simple border
        if self.border_width:
            border = Gtk.Box()
            border.set_size_request(self.border_width, 0)
            border.modify_bg(Gtk.StateType.NORMAL, self.border_color)
            self.boxlib.pack_end(border, False, False, 0)
        # Vbox for treeview and cmd_handler
        vboxlib = Gtk.VBox()
        vboxlib.pack_start(self.grid, True, True, 0)
        self.entry = Gtk.Entry()
        self.entry.set_text("Search ...")
        self.entry.connect("activate", self.cmd_handler)
        self.entry.connect("key_press_event", self.handle_key_press,
                           "cmd_handler")
        vboxlib.pack_end(self.entry, False, False, 0)
        # Entering content
        self.scrollable_treelist = Gtk.ScrolledWindow()
        self.scrollable_treelist.set_vexpand(True)
        self.grid.attach(self.scrollable_treelist, 0, 0, 4, 10)
        # Pack everything
        self.boxlib.pack_start(vboxlib, True, True, 0)
        # Call the function to create the treeview
        self.treeview_create()
        self.scrollable_treelist.add(self.treeview)

    def cmd_handler(self, text):
        """ Handles input from the label, namely if it is a path to be focused
        or a command to be run """
        # Path from input
        path = text.get_text()
        text.set_text("")
        # Save the path to a list
        self.cmd_history.insert(1, path)
        self.cmd_pos = 0
        # Parse different starts
        if path[0] == "!":
            self.run_command(path)
            return
        elif path[0] == "~":
            path = os.path.expanduser("~") + path[1:]
        elif path[0] != "." and path[0] != "/":
            for fil in self.files:
                if path in fil:
                    path = "./" + fil
                    break
        try:
            path = os.path.abspath(path)
            if not os.path.exists(path):
                raise ValueError
            elif os.path.isdir(path):
                self.move_up(path)
            else:
                # If it is an image open it
                self.paths = []
                self.populate([path])
                self.move_index(True, False, 0)
                # And focus it in the treeview so it can be accessed via "l"
                self.last_selected = path
                abspath_list = path.split("/")[1:-1]
                abspath = "/" + "/".join(abspath_list)
                self.move_up(abspath)
                for i, fil in enumerate(self.files):
                    if fil in path:
                        self.treeview.set_cursor(Gtk.TreePath(i), None, False)
                        self.treepos = i
                        break
        except:
            self.err_message("Warning: Not a valid path")

    def run_command(self, cmd):
        """ Run the entered command in the terminal """
        if "%" in cmd:
            cmd = cmd.replace("%", self.files[self.treepos])
        cmd = cmd[1:].split()
        if "*" in cmd:
            cmd.remove("*")
            cmd.extend(self.files)
        try:
            Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
        except:
            self.err_message("Command exited with status 1")

    def history(self, down):
        """ Update the cmd_handler text with history """
        if down:
            self.cmd_pos -= 1
        else:
            self.cmd_pos += 1
        self.cmd_pos = self.cmd_pos % (len(self.cmd_history))
        self.entry.set_text(self.cmd_history[self.cmd_pos])

    def leave_cmd_handler(self):
        self.treeview.grab_focus()
        self.entry.set_text("")

    def insert_cmd_handler(self):
        self.entry.grab_focus()
        self.entry.set_text("")

    def library_toggle(self):
        """ Toggles the library """
        if self.library_toggled:
            self.remember_pos(os.path.abspath("."), self.treepos)
            self.boxlib.hide()
            self.animation_toggled = False  # Now play Gifs
            self.library_toggled = not self.library_toggled
            self.library_focus(False)
        else:
            self.boxlib.show()
            if not self.paths:
                self.scrolled_win.hide()
            else:  # Try to focus the current image in the library
                path = self.paths[self.index].split("/")[:-1]
                path = "/".join(path)
                if path == os.path.abspath("."):
                    self.treeview.set_cursor(Gtk.TreePath([self.index]),
                                             None, False)
                    self.treepos = self.index
            self.animation_toggled = True  # Do not play Gifs with the lib
            self.library_toggled = not self.library_toggled
            self.library_focus(True)
            self.reload(".")  # Markings and other stuff might have changed
        if not self.user_zoomed and self.paths:
            self.zoom_to(0)  # Always rezoom the image

    def library_focus(self, library=True):
        if library:
            if not self.library_toggled:
                self.library_toggle()
            self.treeview.grab_focus()
            self.library_focused = True
        else:
            self.scrolled_win.grab_focus()
            self.library_focused = False
        # Update info for the current mode
        self.update_info()

    def treeview_create(self):
        # Tree View
        current_file_filter = self.filestore(self.datalist_create())
        self.treeview = Gtk.TreeView.new_with_model(current_file_filter)
        # Needed for the movement keys
        self.treepos = 0
        self.treeview.set_enable_search(False)
        # Select file when row activated
        self.treeview.connect("row-activated", self.file_select, True)
        # Handle key events
        self.treeview.add_events(Gdk.EventMask.KEY_PRESS_MASK)
        self.treeview.connect("key_press_event", self.handle_key_press,
                              "library")
        # Add the columns
        for i, name in enumerate(["Num", "Name", "Size", "M"]):
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn(name, renderer, markup=i)
            if name == "Name":
                column.set_expand(True)
                column.set_max_width(20)
            self.treeview.append_column(column)

    def filestore(self, datalist):
        """ Returns the file_filter for the tree view """
        # Filelist in a liststore model
        self.filelist = Gtk.ListStore(int, str, str, str)
        # Numerate each filename
        count = 0
        for data in datalist:
            count += 1
            data.insert(0, count)
            # The data into the filelist
            self.filelist.append(data)

        current_file_filter = self.filelist.filter_new()
        return current_file_filter

    def datalist_create(self):
        """ Returns the list of data for the file_filter model """
        self.datalist = list()
        # Remove unsupported files
        files = self.filelist_create()
        self.files = [
            possible_file
            for possible_file in files
            if mimetypes.guess_type(possible_file)[0] in self.types
            or os.path.isdir(possible_file)]
        # Add all the supported files
        for fil in self.files:
            size = self.filesize[fil]
            marked = ""
            if os.path.abspath(fil) in self.marked:
                marked = "[*]"
            if os.path.isdir(fil):
                fil = "<b>" + fil + "</b>"
            self.datalist.append([fil, size, marked])

        return self.datalist

    def filelist_create(self, dir="."):
        """ Create a filelist from all files in dir """
        # Get data from ls -lh and parse it correctly
        if self.show_hidden:
            p = Popen(['ls', '-lAh', dir], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        else:
            p = Popen(['ls', '-lh', dir], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        data, err = p.communicate()
        data = data.decode(encoding='UTF-8').split("\n")[1:-1]
        files = []
        self.filesize = {}
        for fil in data:
            fil = fil.split()
            # Catch stupid filenames with whitespaces
            filename = " ".join(fil[8:])
            files.append(filename)
            # Number of images in dir as filesize
            if os.path.isdir(filename):
                try:
                    subfiles = os.listdir(filename)
                    subfiles = [
                        possible_file
                        for possible_file in subfiles
                        if mimetypes.guess_type(possible_file)[0] in self.types]
                    self.filesize[filename] = str(len(subfiles))
                except:
                    self.filesize[filename] = "N/A"
            else:
                self.filesize[filename] = fil[4]

        return files

    def file_select(self, alternative, count, b, close):
        """ Focus image or open dir for activated file in library """
        if isinstance(count, str):
            fil = count
        else:
            count = count.get_indices()[0]
            fil = self.files[count]
            self.remember_pos(os.path.abspath("."), count)
        # Catch symbolic links
        if "->" in fil:
            fil = "".join(fil.split(">")[:-1]).split(" ")[:-1]
            fil = "".join(fil)
            fil = os.path.realpath(fil)
            self.move_up(os.path.dirname(fil))
        if os.path.isdir(fil):  # Open the directory
            self.move_up(fil)
        else:  # Focus the image and populate a new list from the dir
            if self.paths and fil in self.paths[self.index]:  # Close if file selected twice
                close = True
            self.paths = []
            count = 0  # Filter directories
            path = 0  # Reload the path, could have changed (symlinks)
            for f in self.files:
                if f in fil:
                    break
                else:
                    path += 1
                    if not os.path.isdir(f):
                        count += 1
            self.treeview.set_cursor(Gtk.TreePath(path), None, False)
            self.treepos = path
            self.populate(self.files)
            # Show the selected file, if thumbnail toggled go out
            if self.thumbnail_toggled:
                self.thumbnail_toggle()
                self.treeview.grab_focus()
            self.move_index(True, False, count)
            self.zoom_to(0)
            # Close the library depending on key and repeat
            if close:
                self.library_toggle()

    def move_up(self, dir="..", start=False):
        """ move (up/to) dir in the library """
        try:
            curdir = os.path.abspath(".")
            os.chdir(dir)
            if not start:
                self.reload(os.path.abspath("."), curdir)
        except:
            self.err_message("Error: directory not accessible")

    def remember_pos(self, dir, count):
        self.dir_pos[dir] = count

    def reload(self, dir, curdir=""):
        """ Reloads the treeview """
        self.scrollable_treelist.remove(self.treeview)
        self.treeview_create()
        self.scrollable_treelist.add(self.treeview)
        self.library_focus(True)
        # Check if there is a saved position
        if dir in self.dir_pos.keys():
            self.treeview.set_cursor(Gtk.TreePath(self.dir_pos[dir]),
                                     None, False)
            self.treepos = self.dir_pos[dir]
        # Check if the last directory is in the current one
        else:
            curdir = curdir.split("/")[-1]
            for i, fil in enumerate(self.files):
                if curdir == fil:
                    self.treeview.set_cursor(Gtk.TreePath([i]), None, False)
                    self.treepos = i
                    break
        self.boxlib.show_all()

    def move_pos_lib(self, forward=True):
        """ Move to pos in lib """
        max = len(self.files) - 1
        if self.num_str:
            pos = int(self.num_str) - 1
            if pos < 0 or pos > max:
                self.err_message("Warning: Unsuported index")
                return False
        elif forward:
            pos = max
        else:
            pos = 0
        try:
            self.treepos = pos
            self.treeview.set_cursor(Gtk.TreePath(self.treepos), None, False)
        except:
            self.err_message("Warning: Unsupported index")
            return False

        self.num_clear()
        return True

    def mark_lib(self):
        current = self.files[self.treepos]
        current = os.path.abspath(current)
        if current in self.marked:
            self.marked.remove(current)
        else:
            self.marked.append(current)
        self.remember_pos(".", self.treepos)
        self.reload(".")
        self.update_info()

    def delete_lib(self):
        current = self.files[self.treepos]
        if os.path.isdir(current):
            self.err_message("Deleting directories is not supported")
        else:
            deldir = os.path.join(os.path.expanduser("~"), ".vimiv/Trash")
            if not os.path.isdir(deldir):
                os.mkdir(deldir)
            # Check if there is already a file with that name in the trash
            delfile = deldir + "/" + os.path.basename(current)
            if os.path.exists(delfile):
                backnum = 1
                while True:
                    ndelfile = delfile+"."+str(backnum)
                    if not os.path.exists(ndelfile):
                        shutil.move(delfile, ndelfile)
                        break
                    backnum += 1
            shutil.move(current, deldir)
            # Just move up one path
            if self.treepos > 0:
                self.treepos -= 1
            self.remember_pos(os.path.abspath("."), self.treepos)
            self.reload(os.path.abspath("."))

    def resize_lib(self, inc=True):
        """ Resize the library and update the image if necessary """
        # Set some reasonable limits to the library size
        if (inc and self.paths and self.library_width < self.winsize[0]-200 or
            inc and not self.paths and self.library_width < self.winsize[0]-20):
            self.library_width += 20
        elif not inc and self.library_width > 160:
            self.library_width -= 20
        self.grid.set_size_request(self.library_width-self.border_width, 10)
        if not self.user_zoomed:
            self.zoom_to(0)

    def hidden_toggle(self):
        self.show_hidden = not self.show_hidden
        self.reload('.')

    def auto_resize(self, w):
        """ Automatically resize image when window is resized """
        if self.win.get_size() != self.winsize:
            self.winsize = self.win.get_size()
            if self.paths and not self.user_zoomed:
                self.zoom_to(0)
            elif not self.paths and self.expand_lib:
                self.grid.set_size_request(self.winsize[0], 10)

    def handle_key_press(self, widget, event, window):
        keyval = event.keyval
        keyname = Gdk.keyval_name(keyval)
        if (keyval == Gdk.KEY_Shift_L or keyval == Gdk.KEY_Shift_R or
                keyval == Gdk.KEY_Alt_L or keyval == Gdk.KEY_Alt_R or
                keyval == Gdk.KEY_Control_L or keyval == Gdk.KEY_Control_R):
            return
        # Check for Control (^) or Mod1 (Alt)
        if event.get_state() & Gdk.ModifierType.CONTROL_MASK:
            keyname = '^{}'.format(keyname)
        if event.get_state() & Gdk.ModifierType.MOD1_MASK:
            keyname = 'Alt+{}'.format(keyname)
        # Loop through binds until found (Calls for improvements)
        for bind in self.binds[window]:
            if keyname == bind[0]:
                funk = bind[1]
                args = bind[2:]
                funk(*args)
                return

    def parse_args(self):
        usage = '%(prog)s [options] [paths ...]'
        parser = argparse.ArgumentParser(usage=usage)
        parser.add_argument("-b", "--bar", action="store_true", dest="sbar",
                            help="display statusbar", default=self.sbar)
        parser.add_argument("-B", "--no-bar", action="store_false", dest="sbar",
                            help="hide statusbar", default=self.sbar)
        parser.add_argument("-l", "--library", action="store_true",
                            dest="library", help="display library",
                            default=self.library_toggled)
        parser.add_argument("-L", "--no-library", action="store_false",
                            dest="library", help="don't display library",
                            default=self.library_toggled)
        parser.add_argument("-f", "--fullscreen", action="store_true",
                            dest="fullscreen", help="start in fullscreen",
                            default=self.fullscreen)
        parser.add_argument("-F", "--no-fullscreen", action="store_false",
                            dest="fullscreen", help="don't start in fullscreen",
                            default=self.fullscreen)
        parser.add_argument("-s", "--shuffle", action="store_true",
                            dest="shuffle", help="shuffle filelist",
                            default=self.shuffle)
        parser.add_argument("-S", "--no-shuffle", action="store_false",
                            dest="shuffle", help="don't shuffle the filelist")
        parser.add_argument("-r", "--recursive", action="store_true",
                            dest="recursive",
                            help="search given directories recursively",
                            default=self.recursive)
        parser.add_argument("-R", "--no-recursive", action="store_false",
                            dest="recursive",
                            help="don't search given directories recursively",
                            default=self.recursive)
        parser.add_argument("--slideshow", action="store_true",
                            help="start slideshow immediately",
                            default=self.slideshow)
        parser.add_argument("--slideshow-delay", type=float,
                            help="set the slideshow delay",
                            default=self.slideshow_delay)
        parser.add_argument("-g", "--geometry", dest="geometry",
                            help="set the starting geometry",
                            default=self.geometry)
        self.files = self.filelist_create()
        parser.add_argument("path", nargs='*', default=self.files)
        args = parser.parse_args()
        self.sbar = args.sbar
        self.library_toggled = args.library
        self.recursive = args.recursive
        self.fullscreen = args.fullscreen
        self.shuffle = args.shuffle
        self.slideshow_delay = args.slideshow_delay
        self.slideshow = args.slideshow
        self.geometry = args.geometry

        self.populate(args.path, True)

    def main(self):
        # Create vimiv directory if it doesn't exist
        vimivdir = os.path.join(os.path.expanduser("~"), ".vimiv")
        if not os.path.isdir(vimivdir):
            os.mkdir(vimivdir)

        # Off we go
        self.parse_args()

        # Move to the directory of the image
        if self.paths:
            os.chdir(os.path.dirname(self.paths[self.index]))

        # Screen
        screen = Gdk.Screen()
        self.screensize = [screen.width(), screen.height()]

        # Gtk window with general settings
        self.win = Gtk.Window()
        self.win.add_events(Gdk.EventMask.KEY_PRESS_MASK |
                            Gdk.EventMask.POINTER_MOTION_MASK)
        self.win.connect('destroy', Gtk.main_quit)
        self.win.connect("check-resize", self.auto_resize)
        self.win.set_icon_name("image-x-generic")

        # Box in which everything gets packed
        self.vbox = Gtk.VBox()
        # Horizontal Box with image and treeview
        self.hbox = Gtk.HBox(False, 0)
        self.win.add(self.vbox)
        # Scrollable window for the image
        self.scrolled_win = Gtk.ScrolledWindow()
        self.hbox.pack_end(self.scrolled_win, True, True, 0)
        self.vbox.pack_start(self.hbox, True, True, 0)

        # Viewport
        self.viewport = Gtk.Viewport()
        self.viewport.set_shadow_type(Gtk.ShadowType.NONE)
        self.scrolled_win.add(self.viewport)
        self.image = Gtk.Image()
        self.viewport.add(self.image)
        self.scrolled_win.connect("key_press_event", self.handle_key_press, "main")

        # Statusbar on the bottom
        self.labelbox = Gtk.HBox(False, 0)
        self.labelbox.set_border_width(12)
        # Two labels for two sides of statusbar and one in the middle for
        # additional info
        self.left_label = Gtk.Label()  # Position and image name
        self.left_label.set_justify(Gtk.Justification.LEFT)
        self.right_label = Gtk.Label()  # Mode and prefixed numbers
        self.right_label.set_justify(Gtk.Justification.RIGHT)
        self.center_label = Gtk.Label()  # Zoom, marked, slideshow, ...
        self.center_label.set_justify(Gtk.Justification.CENTER)
        self.labelbox.pack_start(self.left_label, False, False, 0)
        self.labelbox.pack_start(self.center_label, True, True, 0)
        self.labelbox.pack_end(self.right_label, False, False, 0)
        self.vbox.pack_end(self.labelbox, False, False, 0)
        # Size for resizing image
        self.statusbar_size = self.labelbox.get_allocated_height()

        # Treeview
        self.library()
        self.hbox.pack_start(self.boxlib, False, False, 0)

        # Manipulate Bar
        self.manipulate()
        self.vbox.pack_end(self.hboxman, False, False, 0)
        self.set_default_window_size()
        self.winsize = self.win.get_size()

        self.win.show_all()
        # Show images, if a path was given
        if self.paths:
            self.move_index(True, False, 0)
            # Show library at the beginning?
            if self.library_toggled:
                self.boxlib.show()
            else:
                self.boxlib.hide()
            self.scrolled_win.grab_focus()
            if self.fullscreen:
                self.win.fullscreen()
            # Start in slideshow mode?
            if self.slideshow:
                self.slideshow = False
                self.toggle_slideshow()
            self.toggle_statusbar()
        else:
            self.slideshow = False  # Slideshow without paths makes no sense
            self.toggle_statusbar()
            self.library_focus(True)
            if self.expand_lib:
                self.grid.set_size_request(self.winsize[0], 10)
            self.err_message("No valid paths, opening library viewer")

        # Hide the manipulate bar
        self.hboxman.hide()

        # Finally show the main window
        Gtk.main()


if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    Vimiv().main()
